# 应用程序二进制接口规范

## 基本设计

应用程序二进制接口是与区块链以外的以太坊生态系统中的合同进行交互的标准方式，也是合同到合同交互的标准方式。
数据根据其类型进行编码，如本规范中所述。
编码不是自描述的，因此需要一个模式才能解码。

我们假设合同的接口函数是强类型的，在编译时和静态时都是已知的。
不会提供自检机制。
我们假设所有合同都将具有编译时可用的任何合约的接口定义。

本规范不涉及其接口是动态的或仅在运行时才知道的契约。
如果这些情况变得重要，它们可以作为以太坊生态系统内的设施进行充分处理。

## 功能选择器

函数调用的调用数据的前四个字节指定要调用的函数。
它是函数签名的Keccak(SHA-3)哈希中的第一个(左边，高位在大端)四个字节。
签名被定义为基本原型的规范表达式，即具有括号括起来的参数类型列表的函数名称。
参数类型由一个逗号分隔 - 不使用空格。

## 参数编码

从第五个字节开始，编码的参数跟随。
这种编码也用于其他地方，例如，,返回值和事件参数都以相同的方式编码，而不用四个字节指定函数。

类型

存在以下基本类型：

- `uint<M>`: 无符号整数类型`M`位，`0 <M <= 256`，`M％8 == 0`。 例如,`uint32`，`uint8`，`uint256`。
- `int<M>`: 二进制补码有符号整数类型的`M`位， `0 < M <= 256`, `M % 8 == 0`.
- `address`: 相当于`uint160`，除了假定的解释和语言输入。为了计算函数选择器，使用`地址`。
- `uint`, `int`: 分别为`uint256`，`int256`的同义词。为了计算函数选择器，必须使用`uint256`和`int256`。
- `bool`: 相当于`uint8`限制在值0和1。为了计算函数选择器，使用`bool`。
- `fixed<M>x<N>`: 带符号的定点十进制数`M`位，`8`= M <= 256，`M％8 == 0`和`0 <N <= 80` ,v /(10 ** N)`。
- `ufixed<M>x<N>`: 无符号变量`fixed <M> x <N>`。
- `fixed`, `ufixed`: `fixed128x19`的同义词，`ufixed128x19`的同义词。为了计算函数选择器，必须使用`fixed128x19`和`ufixed128x19`。
- `bytes<M>`: 二进制类型为`M`个字节，`0 <M <= 32`。
- `function`: 地址(20字节)由函数选择器(4字节)填充。,编码与`bytes24`相同。

存在以下(固定大小)数组类型：

- `<type>[M]`: 给定类型的`M`元素的固定长度数组，`M> 0`。

存在以下非固定大小类型：

- `bytes`: 动态大小的字节序列。
- `string`: 动态大小的unicode字符串假定为UTF-8编码。
- `<type>[]`: 给定类型的元素的可变长度数组。

类型可以通过在圆括号内包含一个有限的非负数的数字来组合成一个元组，用逗号分隔：

- `(T1,T2,...,Tn)`: 由`T1`，...，`Tn`，`n> = 0`组成的元组

可以形成元组的元组，元组数组等等。

!!! Note

    除了元组之外，Solidity支持所有类型相同的类型。
    ABI元组类型用于编码Solidity`structs`。

## 编码的形式规范

我们现在将正式指定编码，以便它具有以下属性，如果某些参数是嵌套数组，则这些属性特别有用：

属性:

> 1. 访问一个值所需的读取次数至多是参数数组结构中值的深度，即需要四次读取来检索`a_i [k] [l] [r]`。在以前版本的ABI中，读数的数量与最坏情况下动态参数的总数成线性关系。
> 2. 变量或数组元素的数据不与其他数据交错，并且它是可重定位的，即它只使用相对`地址`

我们区分静态和动态类型。
静态类型就地编码，动态类型在当前块之后的单独分配位置进行编码。

**定义：**以下类型称为`动态`：

- `bytes`
- `string`
- `T[]` 为任何 `T`
- `T[k]` 为任何动态 `T` 和任何 `k > 0`
- `(T1,...,Tk)` 如果任何`Ti`对于`1 <= i <= k`都是动态的

所有其他类型被称为`静态`。

**定义：** len（a）是二进制字符串“a”中的字节数。`len（a）`的类型被假定为`uint256`。

我们将`enc`（实际编码）定义为ABI类型值与二进制字符串的映射，使得当len（enc（X））`取决于`X`的值时，当且仅当'X ,`是动态的。

**定义：**对于任何ABI值`X`，我们递归地定义`enc（X）`，这取决于`X`的类型

- `（T1，...，Tk）`为`k> = 0`和任何类型`T1`，...，`Tk`

    `enc(X) = head(X(1)) ...head(X(k-1)) tail(X(0)) ...tail(X(k-1))`

    其中`X（i）`是数值的'iith`分量，`head`和`tail`是为`Ti`定义的，静态类型为

    > `head（X（i））= enc（X（i））`和tail（X（i））=“”`（空字符串）

    并作为

    > `head(X(i)) = enc(len(head(X(0)) ...head(X(k-1)) tail(X(0)) ...tail(X(i-1))))`
    > `tail(X(i)) = enc(X(i))`

    否则，即，如果“Ti”是动态类型。

    请注意，在动态情况下，head（X（i））`是很好定义的，因为头部长度只取决于类型而不取决于值。
    它的值是`tail（X（i））`相对于'enc（X）`的开始的偏移量。

- `T [k]`对于任何`T`和`k`：

    `enc(X) = enc((X[0], ..., X[k-1]))`

    即，它被编码为好像它是具有相同类型的“k”个元素的元组。

- `T []`其中`X`有`k`个元素（`k`被假定为`uint256`类型）：

    `enc(X) = enc(k) enc([X[1], ..., X[k]])`

    即它被编码为好象它是一个静态大小为“k”的数组，其前缀为元素的数量。

- ```长度为'k'的字节（假定它的类型为`uint256`）：

    'enc（X）= enc（k）pad_right（X）'，即字节数被编码为“uint256”，接着是字节序列的“X”的实际值，接着是最小数量的零值，,字节，使得len（enc（X））是32的倍数。

- `string`:

    `enc（X）= enc（enc_utf8（X））`，即`X`是utf-8编码的，这个值被解释为字节类型，并被进一步编码。

请注意，此后续编码中使用的长度是utf-8编码字符串的字节数，而不是其字符数。

- `uint <M>`：`enc（X）`是`X`的大端编码，在高位（左边）用零字节填充，使得长度为32字节的倍数。
- `address`: 如`uint160`的情况
- `int<M>`: `enc（X）`是`X`的大端二进制补码编码，在高位（左）侧填充，'0xff'填充为负数'X'，零字节为正数'X',该长度是32个字节的倍数。
- `bool`: 就像在'uint8'情况下一样，'1'用于'真'，'0'用于'假'
- `fixed<M>x<N>`: `enc（X）`是`enc（X * 10 ** N）`，其中`X * 10 ** N`被解释为`int256`。
- `fixed`: 如`fixed128x19`的情况
- `ufixed<M>x<N>`: `enc（X）`是`enc（X * 10 ** N）`，其中`X * 10 ** N`被解释为`uint256`。
- `ufixed`: 如`ufixed128x19`的情况
- `bytes<M>`: `enc（X）`是'X'中用零字节填充长度为32的字节序列。

请注意，对于任何`X`，`len（enc（X））`是32的倍数。

## 函数选择器和参数编码

总而言之，用参数`a_1，...，a_n`调用函数`f`编码为

> `（function_selector（f）enc（（a_1，...，a_n））`，`f`的返回值`v_1，...，v_k`被编码为

即这些值被组合成一个元组并被编码。

## 例子

鉴于合同：

    pragma solidity ^0.4.16;

    contract Foo {
      function bar(bytes3[2]) public pure {}
      function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }
      function sam(bytes, bool, uint[]) public pure {}
    }

因此，对于我们的`Foo`示例，如果我们想用参数`69`和`true`调用`baz`，我们将总共传递68个字节，这可以分解为：

- `0xcdcd77c0`: 方法ID。,这是由签名'baz（uint32，bool）'的ASCII形式的Keccak哈希的前4个字节派生而来的。
- `0x0000000000000000000000000000000000000000000000000000000000000045`: 第一个参数，一个uint32值`69`填充到32个字节
- `0x0000000000000000000000000000000000000000000000000000000000000001`: 第二个参数 - 布尔值为“true”，填充为32个字节

总共：

    0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001

它返回一个`bool`。
如果，例如，它返回'false'，它的输出将是单字节数组'0x0000000000000000000000000000000000000000000000000000000000000000'，一个单一的布尔值。

如果我们想用参数`[“abc”，“def”]调用`bar`，我们将总共传递68个字节，分解为：

- `0xfce353f6`: 方法ID。这来自签名`bar（bytes3 [2]）`。
- `0x6162630000000000000000000000000000000000000000000000000000000000`: 这来自签名`bar（bytes3 [2]）`。
- `0x6465660000000000000000000000000000000000000000000000000000000000`: 第一个参数的第二部分，“bytes3”值“def”（左对齐）。

总共：

    0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000

如果我们想用参数`“dave”`，`true`和`[1,2,3]``调用`sam`，我们将总共传递292个字节，分解为：

- `0xa5643bf2`: 方法ID。这是从签名sam（bytes，bool，uint256 []）`派生而来的。请注意`uint`被其规范表示形式`uint256`替代。
- `0x0000000000000000000000000000000000000000000000000000000000000060`: 第一个参数（动态类型）的数据部分的位置，从参数块的开始字节开始测量。在这种情况下，“0x60”。
- `0x0000000000000000000000000000000000000000000000000000000000000001`: 第二个参数：boolean true。
- `0x00000000000000000000000000000000000000000000000000000000000000a0`: 第三个参数（动态类型）的数据部分的位置，以字节为单位测量。在这种情况下，`0xa0`。
- `0x0000000000000000000000000000000000000000000000000000000000000004`: 第一个参数的数据部分，它以元素中字节数组的长度开始，在本例中为4。
- `0x6461766500000000000000000000000000000000000000000000000000000000`: 第一个参数的内容：“”dave“的UTF-8编码（在本例中相当于ASCII）编码，在右侧填充到32个字节。
- `0x0000000000000000000000000000000000000000000000000000000000000003`: 第一个参数的内容：“”dave“的UTF-8编码（在本例中相当于ASCII）编码，在右侧填充到32个字节。
- `0x0000000000000000000000000000000000000000000000000000000000000001`: 第三个参数的第一个条目。
- `0x0000000000000000000000000000000000000000000000000000000000000002`: 第三个参数的第二个条目。
- `0x0000000000000000000000000000000000000000000000000000000000000003`: 第三个参数的第三个条目。

总共：

    0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003

## 动态类型的使用

对具有值'（0x123，[0x456，0x789]，“1234567890”，“Hello，world！”）的签名`f（uint，uint32 []，bytes10，bytes）'的函数的调用在,以下方法：

我们采用`sha3（“f（uint256，uint32 []，bytes10，bytes）”）“的前四个字节，即”0x8be65246“。
然后我们对所有四个参数的头部分进行编码。
对于静态类型`uint256`和`bytes10`，这些值直接是我们想要传递的值，而对于动态类型`uint32 []`和`bytes`，我们使用字节偏移量到数据区的开始位置,，从数值编码开始测量（即不计算包含函数签名散列的前四个字节）。

这些是：

> - `0x0000000000000000000000000000000000000000000000000000000000000123` (`0x123` padded to 32 bytes)
> - `0x0000000000000000000000000000000000000000000000000000000000000080` (offset to start of data part of second parameter, 4*32 bytes, exactly the size of the head part)
> - `0x3132333435363738393000000000000000000000000000000000000000000000` (`"1234567890"` padded to 32 bytes on the right)
> - `0x00000000000000000000000000000000000000000000000000000000000000e0` (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4*32 + 3*32 (see below))

After this, the data part of the first dynamic argument,`[0x456, 0x789]` follows:

> - `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements of the array, 2)
> - `0x0000000000000000000000000000000000000000000000000000000000000456` (first element)
> - `0x0000000000000000000000000000000000000000000000000000000000000789` (second element)

Finally, we encode the data part of the second dynamic argument,`"Hello, world!"`:

> - `0x000000000000000000000000000000000000000000000000000000000000000d` (number of elements (bytes in this case): 13)
> - `0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000` (`"Hello, world!"` padded to 32 bytes on the right)

总的来说，编码是（换行符之后换行符，每个32字节为了清晰起见）：

    0x8be65246
  0000000000000000000000000000000000000000000000000000000000000123
  0000000000000000000000000000000000000000000000000000000000000080
  3132333435363738393000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000e0
  0000000000000000000000000000000000000000000000000000000000000002
  0000000000000000000000000000000000000000000000000000000000000456
  0000000000000000000000000000000000000000000000000000000000000789
  000000000000000000000000000000000000000000000000000000000000000d
  48656c6c6f2c20776f726c642100000000000000000000000000000000000000

## 活动

事件是以太坊日志/事件观察协议的抽象。
日志条目提供合同的地址，一系列最多四个主题和一些任意长度的二进制数据。
事件利用现有的ABI函数来解释这个（与一个接口规范一起）为一个正确类型的结构。

给定一个事件名称和一系列事件参数，我们将它们分成两个子系列：索引的和不是的。
那些被编入索引的，最多可达3个，与事件签名的Keccak散列一起使用，以形成日志条目的主题。
那些没有索引的事件形成事件的字节数组。

实际上，使用这个ABI的日志条目被描述为：

- `address`: 合同地址（本质上由以太坊提供）;
- `topics[0]`: ``keccak（EVENT_NAME +“（”+ EVENT_ARGS.map（canonical_type_of）.join（“，”）+“）”）`（`canonical_type_of`）是一个简单地返回给定参数的规范类型的函数，例如`uint indexed ,foo`，它会返回`uint256`）。如果事件被声明为“匿名”，则不会生成“topics [0]”;
- `topics[n]`: `EVENT_INDEXED_ARGS [n  -  1]`（`EVENT_INDEXED_ARGS`是索引的一系列`EVENT_ARGS`）;
- `data`: `abi_serialise（EVENT_NON_INDEXED_ARGS）`（`EVENT_NON_INDEXED_ARGS`是未编入索引的`EVENT_ARGS`系列，`abi_serialise`是用于从函数返回一系列类型值的ABI序列化函数，如上所述）。

对于所有固定长度的Solidity类型，EVENT_INDEXED_ARGS数组直接包含32字节的编码值。
但是，对于包含`string`，`bytes`和数组的动态长度*类型，`EVENT_INDEXED_ARGS`将包含编码值的* Keccak散列*，而不是直接编码的值。
这允许应用程序高效地查询动态长度类型的值（通过将编码值的散列设置为主题），但是应用程序无法解码他们没有查询的索引值。
对于动态长度类型，应用程序开发人员需要在快速搜索预定值（如果参数为索引）和任意值的易读性（这要求参数不被索引）之间进行权衡。
开发人员可以通过定义具有两个参数的事件（一个索引，一个不打算保持相同的值）来克服这种折衷并实现有效搜索和任意易读性。

## JSON

合约接口的JSON格式由一组函数和/或事件描述给出。
函数描述是一个带有字段的JSON对象：

- `type`: 类型`：``函数``，``构造函数``或``fallback'`（[未命名的默认函数<fallback-function>]（））;
- `name`: 函数的名称;
- `inputs`: 一组对象，其中每个对象都包含：
    - `name`: 参数的名称;
    - `type`: 参数的规范类型（更多下面）。
    - `components`: 用于元组类型（更多）。
- `outputs`: 如果函数不返回任何东西，则可以省略类似于`inputs`的对象数组;
- `payable`: 如果函数接受ether，则为true;默认为false;
- `stateMutability`: （指定不读取区块链状态<pure-functions>]（）），`view`（[指定不修改区块链状态<view-functions>]（） ,），“不支付”和“应付”（与上面的“应付”相同）。
- `constant`: 如果函数是“纯”或“视图”，则为`true`

`type`可以省略，默认为``function“`。

构造函数和回退函数从不具有`name`或`outputs`。
后退功能也没有“输入”。

发送非零以太网到非付费功能将抛出。
不要这样做。

事件描述是一个具有相当类似字段的JSON对象：

- `type`: 总是`“事件”`
- `name`: 事件的名称;
- `inputs`: 一组对象，其中每个对象都包含：
    - `name`: 参数的名称;
    - `type`: 参数的规范类型（更多下面）。
    - `components`: 用于元组类型（更多）。
    - `indexed`: 如果该字段是日志主题的一部分，则为“真”;如果该日志的数据段之一为“假”，则为“真”。
- `anonymous`: 如果该事件被声明为“匿名”，则为“true”。

例如,

    pragma solidity ^0.4.0;

    contract Test {
  function Test() public { b = 0x12345678901234567890123456789012; }
  event Event(uint indexed a, bytes32 b);
  event Event2(uint indexed a, bytes32 b);
  function foo(uint a) public { Event(a, b); }
  bytes32 b;
    }

会导致JSON：

```json
[{
"type":"event",
"inputs": [{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}],
"name":"Event"
}, {
"type":"event",
"inputs": [{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}],
"name":"Event2"
}, {
"type":"function",
"inputs": [{"name":"a","type":"uint256"}],
"name":"foo",
"outputs": []
}]
```

### 处理元组类型

尽管这些名称有意不是ABI编码的一部分，但它们确实在JSON中包含很多意义，以便将其显示给最终用户。
该结构以如下方式嵌套：

成员`name`，`type`和可能`components`的对象描述了一个类型变量。
规范类型被确定，直到达到元组类型并且直到该点的字符串描述被存储在具有单词“tuple”的“类型”前缀中，即，它将是“元组”，后面是“[]”的序列并且,`[k]`带有整数`k`。
然后将元组的元素存储在成员`components`中，它是数组类型的，并且具有与顶级对象相同的结构，除了在那里不允许使用`indexed`。

作为例子，代码

    pragma solidity ^0.4.19;
    pragma experimental ABIEncoderV2;

    contract Test {
  struct S { uint a; uint[] b; T[] c; }
  struct T { uint x; uint y; }
  function f(S s, T t, uint a) public { }
  function g() public returns (S s, T t, uint a) {}
    }

会导致JSON：

```json
[
  {
    "name": "f",
    "type": "function",
    "inputs": [
  {
    "name": "s",
    "type": "tuple",
    "components": [
  {
    "name": "a",
    "type": "uint256"
  },
  {
    "name": "b",
    "type": "uint256[]"
  },
  {
    "name": "c",
    "type": "tuple[]",
    "components": [
      {
    "name": "x",
    "type": "uint256"
      },
      {
    "name": "y",
    "type": "uint256"
      }
    ]
  }
    ]
  },
  {
    "name": "t",
    "type": "tuple",
    "components": [
  {
    "name": "x",
    "type": "uint256"
  },
  {
    "name": "y",
    "type": "uint256"
  }
    ]
  },
  {
    "name": "a",
    "type": "uint256"
  }
    ],
    "outputs": []
  }
]
```

## 非标准包装

Solidity支持非标准打包模式，其中：

- 没有[函数选择器<abi_function_selector>]（）被编码,
- 短于32字节的类型既不填零也不签名扩展
- 动态类型在原地进行编码并且没有长度。

作为编码int1，bytes1，uint16，字符串值为-1，0x42，0x2424，“Hello，world！”的示例的结果是：

    0xff42242448656c6c6f2c20776f726c6421
  ^^         int1(-1)
    ^^       bytes1(0x42)
  ^^^^       uint16(0x2424)
      ^^^^^^^^^^^^^^^^^^^^^^^^^^ string("Hello, world!") without a length field

更具体地说，每个静态大小的类型占用的字节数与它的范围一样多，而动态大小的类型如`string`，`bytes`或`uint []`在没有它们的长度字段的情况下被编码。
这意味着只要有两个动态大小的元素，编码就不明确。