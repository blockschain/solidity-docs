# 安全考虑

虽然构建可按预期工作的软件通常非常容易,但要检查没有人可以以预料之外的方式使用它,要困难得多.

在Solidity中,这更加重要,因为您可以使用智能合约来处理代币或可能更有价值的东西.
此外,智能合约的每一次执行都在公开场合进行,除此之外,源代码通常可用.

当然,你总是需要考虑有多大的风险：你可以将智能合约与对公众开放的Web服务(以及对恶意行为者)以及甚至是开放源代码进行比较.
如果您只将该购物清单存储在该Web服务上,则可能不必太在意,但如果您使用该Web服务管理您的银行账户,则应该更加小心.

本节将列出一些陷阱和一般安全建议,但当然可能永远不会完整.
另外,请记住,即使您的智能合约代码没有缺陷,编译器或平台本身也可能有错误.
可以在已知错误列表中找到编译器的一些公开已知安全相关[错误列表](known_bugs.md),这些错误也是机器可读的.
请注意,有一个错误赏金程序涵盖了Solidity编译器的代码生成器.

与往常一样,使用开源文档,请帮助我们扩展本节(特别是,一些示例不会受到伤害)！

## 陷阱

### 私人信息和随机性

您在智能合约中使用的所有内容都是公开可见的,即使是本地变量和标记为`private`的状态变量.

如果你不希望矿工能够作弊,在智能合约中使用随机数字是相当棘手的.

### 重新进入

合约(A)与另一合约(B)的任何互动以及乙方的任何转让均将控制移交给该合约(B).
这使得在这个交互完成之前B可以回调A.
举一个例子,下面的代码包含一个bug(它只是一个片段而不是一个完整的合约)：

    pragma solidity ^0.4.0;

    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract Fund {
        /// Mapping of 以太币 shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            if (msg.sender.send(shares[msg.sender]))
            shares[msg.sender] = 0;
        }
    }

这里的问题并不是太严重,因为作为send的一部分,燃料的含量有限,但它仍然暴露出一个弱点：以太转移总是包含代码执行,所以接收方可能是一个合约,可以调回`withdraw`.
这将让它得到多个退款,并基本上检索合约中的所有以太网.
特别是,下面的合约将允许攻击者多次退款,因为它使用`呼叫`,默认情况下转发所有剩余的气体：

    pragma solidity ^0.4.0;
    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract Fund {
        /// Mapping of 以太币 shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            if (msg.sender.call.value(shares[msg.sender])())
            shares[msg.sender] = 0;
        }
    }

为了避免重新入侵,您可以使用Checks-Effects-Interactions模式,详情如下：

    pragma solidity ^0.4.11;

    contract Fund {
        /// Mapping of 以太币 shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            var share = shares[msg.sender];
            shares[msg.sender] = 0;
            msg.sender.transfer(share);
        }
    }

请注意,重入不仅是以太转移的影响,而且是任何其他合约的功能调用的影响.
此外,您还必须考虑多合约情况.
被叫合约可以修改您依赖的另一份合约的状态.

### 燃料限制和循环

没有固定迭代次数的循环(例如取决于存储值的循环)必须小心使用：由于块气体限制,交易只能消耗一定量的气体.
无论是明确的还是仅仅由于正常的操作,循环中的迭代次数可能会超出堵塞气体限制,这会导致整个合约在某个点停滞.
这可能不适用于仅执行以从区块链读取数据的`constant`功能.
尽管如此,这些功能可能会被其他合约作为链上操作的一部分进行调用,并将其拖延.
请在合约文件中明确说明这些情况.

### 发送和接收以太币

- 合约和`外部账户`都不能阻止有人送他们以太.合约可以作出反应并拒绝定期转移,但有些方法可以在不创建消息呼叫的情况下移动以太网.一种方法是简单地将我的`合约地址`和第二种方式使用`selfdestruct(x)`.
- 如果合约收到以太币(没有调用函数),则执行回退函数.如果它没有后备功能,以太币将被拒绝(通过抛出异常).在执行回退功能时,合约只能依靠当时可用的`燃料津贴`(2300燃料).这笔津贴不足以以任何方式访问存储.为确保您的合约能够以此方式接收以太币,请检查故障预置功能的气体要求(例如,在Remix的`详细信息`部分中).
- 有一种方法可以使用`addr.call.value(x)()`将更多的气体转发给接收合约.这与`addr.transfer(x)`基本相同,只是它转发了所有剩余的气体,并且打开了接收方执行更昂贵操作的能力(并且它只返回失败代码并且不会自动传播错误,).这可能包括回拨发送合约或您可能没有想到的其他状态更改.因此它为诚实用户提供了极大的灵活性,同时也为恶意行为者提供了很大的灵活性
- 如果你想使用`address.transfer`发送以太网,有一些细节需要注意：
    1. 如果收件人是合约,它将导致其执行回退功能,从而可以回拨发送合约.
    2. 由于通话深度超过1024,发送以太网可能会失败.由于呼叫者完全控制呼叫深度,他们可以强制传输失败;,考虑这种可能性或使用`send`并确保始终检查其返回值.更好的是,用收款人可以取消以太币的模式写下你的合约.
    3. 发送以太也可能失败,因为接收方合约的执行需要超过分配数量的气体(显式地使用`require`,`assert`,`revert`,`throw`或因为操作太昂贵) - 它,`耗尽气体`(OOG).如果您使用`transfer`或`send`进行返回值检查,这可能为收件人提供阻止发送合约进度的方法.同样,这里的最佳做法是使用[`撤回`模式而不是`发送`模式](withdrawal_pattern).

### Callstack深度

外部函数调用可能会随时失败,因为它们超过1024的最大调用堆栈.
在这种情况下,Solidity会引发异常.
恶意行为者在与你的合约交互之前可能会强制将这个调用堆栈设置为高价值.

请注意,如果调用堆栈已耗尽,而在此情况下返回`false`,那么`.send()`不会抛出异常.
低级函数`.call()`,`.callcode()`和`.delegatecall()`的行为方式相同.

### tx.origin

切勿使用tx.origin进行授权.假设你有这样的钱包合约：

    pragma solidity ^0.4.11;

    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract TxUserWallet {
    address owner;

    function TxUserWallet() public {
    owner = msg.sender;
    }

    function transferTo(address dest, uint amount) public {
    require(tx.origin == owner);
    dest.transfer(amount);
    }
    }

现在有人欺骗你将以太币发送到这个攻击钱包的地址：

    pragma solidity ^0.4.11;

    interface TxUserWallet {
    function transferTo(address dest, uint amount) public;
    }

    contract TxAttackWallet {
    address owner;

    function TxAttackWallet() public {
    owner = msg.sender;
    }

    function() public {
    TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
    }
    }

如果您的钱包已经检查了`msg.sender`进行授权,它将获得攻击钱包的地址,而不是所有者地址.
但通过检查`tx.origin`,它会得到启动交易的原始地址,该交易仍是所有者地址.
攻击钱包立即消耗您的所有资金.

### 末节

- 在`for(var i = 0; i <arrayName.length; i ++){...}`中,`i`的类型将是`uint8`,因为这是保存该值所需的最小类型` ,0`.如果数组有超过255个元素,则循环不会终止.
- 函数的`constant`关键字目前不被编译器强制执行.此外,它不是由EVM实施的,所以`声称`保持不变的合约功能可能仍然会导致状态的变化.
- 此外,它不是由EVM实施的,所以`声称`保持不变的合约功能可能仍然会导致状态的变化.如果您访问`msg.data`,这一点尤其重要 - 它会带来可塑性风险：您可以编写事务,调用函数为`f(uint8 x)`,原始字节参数为0xff000001和0x00000001.两者都被提交给合约,并且就`x`而言,它们看起来像数字`1`,但`msg.data`将会不同,所以如果你使用`keccak256(msg.data)`做任何事情,,你会得到不同的结果.

## 建议

### 限制以太币的数量

限制可以存储在智能合约中的以太网(或其他代币)数量.
如果您的源代码,编译器或平台有错误,这些资金可能会丢失.
如果你想限制你的损失,限制以太币的数量.

### 保持小型化和模块化

保持合约规模小,易于理解.
在其他合约或库中找出无关的功能.
关于源代码质量的一般建议当然适用：限制局部变量的数量,函数的长度等等.
记录你的功能,以便其他人可以看到你的意图是什么,以及它是否与代码不同.

### 使用检查 - 效果 - 互动模式

大多数函数将首先执行一些检查(谁调用函数,是范围内的参数,他们是否发送了足够多的以太币,人员是否具有代币等).
这些检查应该先完成.

作为第二步,如果所有检查都通过了,则应该对当前合约的状态变量产生影响.
与其他合约的交互应该是任何功能的最后一步.

早期合约延迟了一些效果,并等待外部函数调用以非错误状态返回.
由于上述重入问题,这通常是一个严重的错误.

请注意,对已知合约的调用也可能导致对未知合约的调用,所以最好始终应用此模式.

### 包含故障安全模式

在使系统完全分散化的同时将删除任何中介,这可能是一个好主意,特别是对于新代码,可能包含某种故障安全机制：

您可以在智能合约中添加一个函数,执行一些自我检查,如`有任何以太币泄露？`,`代币的总和是否等于合约的余额？`,或类似的东西.
请记住,你不能使用太多的气体,所以通过脱链计算可能需要帮助.

如果自检失败,合约会自动切换到某种`故障安全`模式,例如禁用大多数功能,将控制权移交给固定和可信的第三方,或者仅将合约转换为简单的`s把我的钱还给我`合约.

## 正式验证

使用形式验证,可以执行自动化的数学证明,证明源代码符合特定的正式规范.
规范仍然是正式的(就像源代码一样),但通常要简单得多.

请注意,形式验证本身只能帮助你理解你所做的事情(规范)和你如何做(实际实现)之间的差异.
您仍然需要检查规格是否是您想要的,并且您没有错过任何意想不到的效果.