# 智能合约简介

## 一个简单的智能合约

让我们从最基本的例子开始。 如果你现在不了解所有的事情，这很好，我们将在稍后详细介绍。

### 存储

```solidity
    pragma solidity ^0.4.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public constant returns (uint) {
            return storedData;
        }
    }
```

第一行简单地说明源代码是为Solidity版本0.4.0编写的，或者是任何不会破坏功能的新代码 (直到但不包括0.5.0版).
这是为了确保合约不会突然与新的编译器版本有所不同。 关键字`pragma`就是这样调用的，因为一般来说，编译指示是编译器关于如何处理源代码的指令 (例如 [pragma once][1]).

Solidity意义上的契约是驻留在以太坊区块链上特定地址的代码（它的*solidity*）和数据（它的*state*）的集合。 'uint storedData'这一行声明了一个名为`storedData`的类型为`uint`的状态变量（256位的无符号整数）.
您可以将其视为数据库中的单个插槽，通过调用管理数据库的代码的函数可以查询和修改它。 在以太坊的情况下，这通常是拥有合约。 在这种情况下，函数`set`和`get`可以用来修改或检索变量的值。

为了访问一个状态变量，你不需要在其他语言中常见的前缀`this.`。

除了允许任何人存储单一号码，世界上任何人都无法访问（可行）的方式来阻止您发布此号码，该合约还没有做太多的工作（由于Ethereum构建的基础设施）。
当然，任何人都可以用不同的值再次调用`set`并覆盖您的号码，但号码仍将存储在区块链的历史记录中。
稍后，我们将看到如何强制实施访问限制，以便只有您可以更改号码。

!!! Note

    所有标识符（合约名称，函数名称和变量名称）都限制为ASCII字符集。 可以将UTF-8编码的数据存储在字符串变量中。

!!! Warning

    使用Unicode文本时要小心，因为类似看起来（甚至相同）的字符可以具有不同的代码点，并且因此将被编码为不同的字节数组。

### 子例子

以下合约将实施加密货币的最简单形式。
可以凭空产生硬币，但只有创建合约的人才能做到这一点（实施不同的发行计划是微不足道的）。
此外，任何人都可以互相发送硬币，而无需使用用户名和密码进行注册 - 您只需要一个以太坊密钥对。

```solidity
    pragma solidity ^0.4.0;

    contract Coin {
        // The keyword "public" makes those variables
        // readable from outside.
        address public minter;
        mapping (address => uint) public balances;

        // Events allow light clients to react on
        // changes efficiently.
        event Sent(address from, address to, uint amount);

        // This is the constructor whose code is
        // run only when the contract is created.
        function Coin() public {
            minter = msg.sender;
        }

        function mint(address receiver, uint amount) public {
            if (msg.sender != minter) return;
            balances[receiver] += amount;
        }

        function send(address receiver, uint amount) public {
            if (balances[msg.sender] < amount) return;
            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            Sent(msg.sender, receiver, amount);
        }
    }
```

这份合约引入了一些新的概念，让我们一一浏览。

'address public minter'行声明了一个可公开访问的类型为地址的状态变量。 “地址”类型是一个不允许任何算术运算的160位值。 它适用于存储属于外部人员的合约或钥匙对的地址。 关键字`public`自动生成一个函数，允许您访问状态变量的当前值。 没有这个关键字，其他合约就无法访问变量。 该功能看起来像这样:

    function minter() returns (address) { return minter; }

当然，像这样添加一个函数是行不通的，因为我们会有一个名字相同的函数和一个状态变量，但是希望您能够明白 - 编译器会为您解决这个问题。

下一行`mapping (address => uint) public balances;`也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将地址映射为无符号整数。 映射可以看作[散列表](https://en.wikipedia.org/wiki/Hash_table)，它被虚拟初始化，这样每个可能的键都存在并映射到一个字节表示全为零的值。
但是，这种类比并不太过分，因为它既不可能获得映射的所有键的列表，也不可能获得所有值的列表。
因此，要么记住（或更好地保留列表或使用更高级的数据类型）添加到映射中的内容，要么在不需要这样的上下文中使用它，就像这样。
在这种情况下，由`public`关键字创建的[getter函数]](getter-functions.md)有点复杂。
它大致如下所示：

    function balances(address _account) public view returns (uint) {
        return balances[_account];
    }

如您所见，您可以使用此功能轻松查询单个帐户的余额。

The line `event Sent(address from, address to, uint amount);` declares a so-called "event" which is fired in the last line of the function `send`.
用户界面（当然也包括服务器应用程序）可以在没有太多成本的情况下侦听在区块链上被触发的事件。
只要它被触发，监听器也会收到`from`，`to`和`amount`参数，这使得跟踪交易变得很容易。
为了听这个事件，你可以使用：

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

注意如何从用户界面调用自动生成的函数`balances`。

特殊功能`Coin`是在创建合约时运行的构造函数，不能在事后调用。
它永久存储创建契约的人的地址：`msg`（与`tx`和`block`一起）是一个神奇的全局变量，它包含一些允许访问区块链的属性。
`msg.sender`始终是当前（外部）函数调用的来源地址。

最后，实际结束于合约并且可以由用户和合约调用的功能是`mint`和`send`。
如果除创建合约的帐户以外的任何人调用“mint”，则不会发生任何事情。
另一方面，任何人（已经有一些这些硬币）都可以使用`send`发送硬币给其他人。
请注意，如果您使用此合约将硬币发送到某个地址，则当您在区块链浏览器中查看该地址时，您将看不到任何内容，因为您发送硬币和已更改的余额仅存储在此数据存储中,特定的硬币合约。
通过使用事件，创建追踪新硬币交易和余额的“区块链探索器”相对容易。

## 区块链基础知识

区块链作为一个概念对于程序员来说并不是很难理解。
原因是大部分的复杂性（挖掘，[哈希] [2]，[椭圆曲线密码学] [5]，[对等网络] [3]等等）只是为了提供一定的,一套功能和承诺。
一旦您接受了这些功能，您就不必担心底层技术 - 或者您是否必须知道Amazon的AWS如何在内部使用才能使用它？

### 交易

区块链是全球共享的事务数据库。
这意味着每个人都可以通过参与网络阅读数据库中的条目。
如果你想改变数据库中的某些东西，你必须创建一个所谓的事务，这个事务必须被所有其他人接受。
单词事务意味着你想要做的改变（假设你想同时改变两个值）要么根本没有完成，要么完全应用。
而且，当你的交易被应用到数据库时，其他交易都不能改变它。

举个例子，设想一个表格，列出电子货币中所有账户的余额。
如果请求从一个账户转账到另一个账户，数据库的交易性质确保了如果从一个账户扣除金额，它总是被添加到另一个账户。
如果由于任何原因，将金额添加到目标帐户是不可能的，则源帐户也不会被修改。

此外，交易总是由发件人（创建者）加密签署。
这使得保护对数据库特定修改的访问变得非常简单。
在电子货币的例子中，一个简单的支票确保只有持有账户钥匙的人可以从中转账。

### 块

用比特币术语来说，要克服的一个主要障碍就是所谓的“双重支出攻击”：如果网络中存在两个都希望清空账户的交易（即所谓的冲突），会发生什么？

这个抽象的答案是，你不必在意。
交易顺序将为您选择，交易将被捆绑到所谓的“块”中，然后它们将在所有参与节点中执行和分配。
如果两笔交易相互抵触，那么最终成为第二笔交易的交易将被拒绝并且不成为该块的一部分。

这些块在时间上形成线性序列，这就是“区块链”这个词来自何处。
块以相当规则的间隔添加到链中 - 对于以太坊来说，这大约每17秒钟一次。

作为“订单选择机制”（称为“采矿”）的一部分，可能会发生块不时被还原的情况，但仅限于链的“尖端”。
顶部添加的块越多，其可能性越小。
因此，您的交易可能会被还原，甚至从区块链中移除，但您等待的时间越长，可能性越小。

## 以太坊虚拟机器

### 概观

以太坊虚拟机或EVM是以太坊智能合约的运行环境。
它不仅仅是沙盒，而且是完全隔离的，这意味着EVM内部运行的代码无法访问网络，文件系统或其他进程。
智能合约甚至对其他智能合约的访问权限有限。

### 帐号

在以太坊有两种帐户共享相同的地址空间：**由公私密钥对（即人类）和**合约帐户**控制的外部帐户**，这些帐户由代码控制,该帐户。

外部账户的地址由公钥确定，而合约地址在合约创建时确定（它来自创建者地址和从该地址发送的交易数量，即所谓的“,随机数“）。

无论帐户是否存储代码，这两种类型均由EVM平等对待。

每个帐户都有一个持久性键值存储，将256位字映射为256位字，称为** storage **。

此外，每个账户在Ether中都有一个**余额**（精确到“Wei”），可以通过发送包含以太网的交易进行修改。

### 交易

交易是从一个帐户发送到另一个帐户（可能是相同的或特殊的零帐户，见下文）的消息。
它可以包含二进制数据（它的有效载荷）和以太网。

如果目标账户包含代码，则执行该代码并将有效负载作为输入数据提供。

如果目标账户是零账户（地址为“0”的账户），则该交易将创建**新合约**。
如前所述，该合约的地址不是零地址，而是源自发件人的地址及其发送的交易数（“随机数”）。
这种合约创建事务的有效载荷被视为EVM字节码并执行。
此执行的输出永久存储为合约的代码。
这意味着为了创建合约，您不会发送合约的实际代码，而是实际返回代码的代码。

### 燃料

在创建之后，每笔交易都会收取一定数量的**天然气**，其目的是限制执行交易所需的工作量，并为此付款。
当EVM执行交易时，天然气会根据具体规则逐渐耗尽。

**天然气价格**是由交易的创建者设定的值，其必须从发送账户向前支付`gas_price * gas`。
如果执行后留下一些气体，它将以同样的方式退还。

如果天然气在任何时候用完（即它是负值），就会触发一个废气异常，这将恢复当前调用框架中对状态所做的所有修改。

### 存储，内存和堆栈

每个帐户都有一个称为**存储**的永久存储区。
存储是将256位字映射到256位字的键值存储。
从合约中列举存储是不可能的，并且读取更加昂贵，甚至更改存储。
除了自己的合约外，合约不能读取或写入任何存储。

第二个内存区域称为**内存**，其中一个合约为每个消息调用获得一个新鲜清除的实例。
存储器是线性的，可以在字节级寻址，但读取限制为256位宽度，写入可以是8位或256位宽。
当访问（读取或写入）先前未触及的内存字（即字中的任何偏移量）时，内存由一个字（256位）扩展。
在扩张时，必须支付天然气的成本。
内存越大，其成本越高（它按比例调整）。

EVM不是注册机器，而是堆栈机器，因此所有计算都在称为**堆栈**的区域执行。
它具有1024个元素的最大尺寸并且包含256位的字。
通过以下方式将访问权限限制在顶端：可以将最顶层的16个元素中的一个复制到堆栈顶部，或者将最顶层的元素与其下面的16个元素中的一个交换。
所有其他操作从堆栈中取最上面的两个（或一个或多个，取决于操作）元素，并将结果推送到堆栈上。
当然，可以将堆栈元素移动到存储器或内存中，但不可能只是访问堆栈中较深的任意元素，而无需先删除堆栈的顶部。

### 指令系统

EVM的指令集保持最小，以避免可能导致共识问题的错误实现。
所有指令都以基本数据类型（256位字）进行操作。
通常的算术，比特，逻辑和比较操作都存在。
有条件的和无条件的跳转是可能的。
此外，合约可以访问当前块的相关属性，如其编号和时间戳。

### 消息呼叫

通过消息调用，合约可以调用其他合约或将以太网发送给非合约账户。
消息调用与事务类似，因为它们具有源，目标，数据有效载荷，以太网，天然气和返回数据。
事实上，每个交易都包含一个顶级的消息调用，这反过来又可以创建更多的消息调用。

合约可以决定剩余的**气体应该在内部的信息通知中发送多少，以及要保留多少。
如果在内部调用（或任何其他异常）中发生了气体异常异常，则会通过放入堆栈中的错误值来标记此信息。
在这种情况下，只有与呼叫一起发送的气体用完。
在Solidity中，在这种情况下，默认情况下调用契约会导致手动异常，所以异常会“唤起”调用堆栈。

正如已经说过的那样，被叫合约（可以与主叫方相同）将收到一个新鲜清除的内存实例，并可以访问呼叫有效载荷 - 将在名为** calldata **的单独区域中提供。
完成执行后，它可以返回将存储在调用方预先分配的调用方内存中的位置的数据。

调用**受限**深度为1024，这意味着对于更复杂的操作，循环应优先于递归调用。

### Delegatecall / Callcode和库

消息调用存在一个特殊的变体，命名为** delegatecall **，它与消息调用相同，除了目标地址上的代码在调用协议和msg.sender的上下文中执行以及,`msg.value`不会改变它们的值。

这意味着合约可以在运行时动态加载来自不同地址的代码。
存储，当前地址和余额仍然是指呼叫合约，只有代码来自被叫地址。

这使得可以在Solidity中实现“库”功能：可用于合约存储的可重复使用的库代码，例如，,以实现一个复杂的数据结构。

### 日志

可以将数据存储在专门索引的数据结构中，该数据结构一直映射到块级别。
这个被称为**日志**的特性被Solidity用来实现** events **。
合约创建后无法访问日志数据，但可以从区块链之外高效访问它们。
由于日志数据的某些部分存储在[布隆过滤器][4]中，因此可以以高效和密码安全的方式搜索此数据，因此不会下载整个区块链（“轻客户端”）的网络对等方,仍然可以找到这些日志。

### 创建

契约甚至可以使用特殊的操作码创建其他契约（即它们不会简单地调用零地址）。
这些**创建调用**和正常消息调用之间唯一的区别在于有效负载数据被执行，并且结果作为代码存储并且调用者/创建者在堆栈上接收新协议的地址。

### 自启动

从区块链中删除代码的唯一可能性是当该地址的合约执行“selfdestruct”操作时。
存储在该地址的剩余Ether被发送到指定的目标，然后将存储和代码从状态中移除。

!!! Warning

    即使合约的代码不包含对“selfdestruct”的调用，它仍然可以使用`delegatecall`或`callcode`执行该操作。

!!! Note

    旧合约的修剪可能会或可能不会由以太坊客户实施。 另外，归档节点可以选择无限期地保持合约存储和代码。

!!! note

    目前**外部帐户**不能从状态中删除。

[1]: https://en.wikipedia.org/wiki/Pragma_once
[2]: https://en.wikipedia.org/wiki/Cryptographic_hash_function
[3]: https://en.wikipedia.org/wiki/Peer-to-peer
[4]: https://en.wikipedia.org/wiki/Bloom_filter
[5]: https://en.wikipedia.org/wiki/Elliptic_curve_cryptography